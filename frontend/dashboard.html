<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ElderSafe Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Use the UMD adapter bundle (v3) which matches Chart.js v4 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.min.js"></script>
        <script src="config.js"></script>
        <link rel="stylesheet" href="styles.css">
</head>
<body>
        <header class="site-header">
            <div class="inner">
                <div class="logo">ElderSafe</div>
                <nav class="nav">
                    <a href="/">Live</a>
                    <a href="/dashboard.html" class="active">Dashboard</a>
                </nav>
            </div>
        </header>

        <main class="container">
            <section class="hero">
                <div>
                    <h1>ElderSafe Historical Dashboard</h1>
                    <p class="muted small">Trends and recent events (last 24 hours)</p>
                </div>
                <!-- <div class="cta">
                    <a class="btn btn-secondary" href="/">Live View</a>
                </div> -->
            </section>

            <div class="charts">
                <div class="chart-card">
                    <h4 class="chart-title">Temperature (°C)</h4>
                    <canvas id="tempChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">Humidity (%)</h4>
                    <canvas id="humChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">G-Force</h4>
                    <canvas id="gForceChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">Falls</h4>
                    <canvas id="fallChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">Emotion</h4>
                    <canvas id="emotionChart" width="400" height="200"></canvas>
                </div>
            </div>

    <script>
        // (SMA removed) dashboard will show raw series only

        // Map emotions to numbers for charting
        const emotionMap = {
            'Neutral': 0,
            'Happy': 1,
            'Sad': 2,
            'Surprised': 3,
            'No Face': -1
        };

        function toTimePoints(arr) {
            // Convert [{time, value}] -> [{ts: Date, label: string, y: number|null}] and filter invalid dates
            const out = [];
            for (const d of (arr || [])) {
                // Normalize ISO timestamp: truncate fractional seconds to milliseconds if needed
                let t = d.time;
                try {
                    if (typeof t === 'string') {
                        t = t.replace(/(\.\d{3})\d+Z$/, '$1Z');
                    }
                } catch (e) { /* ignore */ }
                const dt = new Date(t);
                if (isNaN(dt.getTime())) continue; // skip invalid timestamps
                const raw = d.value;
                const y = (typeof raw === 'number') ? raw : (isNaN(Number(raw)) ? null : Number(raw));
                // label formatted for readability
                const label = dt.toLocaleString();
                out.push({ ts: dt, label: label, y: y });
            }
            return out;
        }

        async function loadDashboard() {
            try {
                const response = await fetch(BASE_URL + '/dashboard_data');
                const data = await response.json();

                const tempPoints = toTimePoints(data.temp_data || []);
                const humPoints = toTimePoints(data.hum_data || []);
                const gForcePoints = toTimePoints(data.g_force_data || []);
                const fallPoints = (data.fall_data || []).map(d => ({ x: new Date(d.time), y: Number(d.value) }));
                const emotionPoints = (data.emotion_data || []).map(d => {
                    // normalize timestamp similar to toTimePoints
                    let t = d.time;
                    try {
                        if (typeof t === 'string') {
                            t = t.replace(/(\.\d{3})\d+Z$/, '$1Z');
                        }
                    } catch (e) { }
                    const dt = new Date(t);
                    if (isNaN(dt.getTime())) return null;
                    const raw = d.value;
                    let yVal = null;
                    if (typeof raw === 'number') {
                        yVal = raw;
                    } else if (!isNaN(Number(raw))) {
                        yVal = Number(raw);
                    } else if (emotionMap[raw] !== undefined) {
                        yVal = emotionMap[raw];
                    } else {
                        yVal = -1;
                    }
                    return { ts: dt, label: dt.toLocaleString(), y: (isNaN(Number(yVal)) ? null : Number(yVal)) };
                }).filter(Boolean);

                // SMA removed — only plotting raw values

                const commonOptions = {
                    plugins: { legend: { position: 'top' } },
                    scales: {
                        x: {
                            type: 'category',
                            ticks: { maxRotation: 45, autoSkip: true, maxTicksLimit: 12 }
                        }
                    },
                    elements: { point: { radius: 0 }, line: { tension: 0.2 } },
                    interaction: { mode: 'nearest', intersect: false }
                };

                // Temperature (use category labels)
                const tempLabels = tempPoints.map(p => p.label);
                const tempValues = tempPoints.map(p => p.y);
                const tempSMAVals = tempSMA.map(p => p.y);
                new Chart(document.getElementById('tempChart'), {
                    type: 'line',
                    data: {
                        labels: tempLabels,
                        datasets: [
                            { label: 'Temperature (°C)', data: tempValues, borderColor: 'red', backgroundColor: 'rgba(255,0,0,0.05)', fill: false, pointRadius: 2 },
                            
                        ]
                    },
                    options: commonOptions
                });

                // Humidity
                const humLabels = humPoints.map(p => p.label);
                const humValues = humPoints.map(p => p.y);
                const humSMAVals = humSMA.map(p => p.y);
                new Chart(document.getElementById('humChart'), {
                    type: 'line',
                    data: {
                        labels: humLabels,
                        datasets: [
                            { label: 'Humidity (%)', data: humValues, borderColor: 'blue', backgroundColor: 'rgba(0,0,255,0.05)', fill: false, pointRadius: 2 },
                            
                        ]
                    },
                    options: commonOptions
                });

                // G-Force
                const gLabels = gForcePoints.map(p => p.label);
                const gValues = gForcePoints.map(p => p.y);
                const gSMAVals = gForceSMA.map(p => p.y);
                new Chart(document.getElementById('gForceChart'), {
                    type: 'line',
                    data: {
                        labels: gLabels,
                        datasets: [
                            { label: 'G-Force', data: gValues, borderColor: 'green', backgroundColor: 'rgba(0,128,0,0.05)', fill: false, pointRadius: 2 },
                            
                        ]
                    },
                    options: commonOptions
                });

                // Fall detection - plot as points on same category labels
                const fallLabels = tempPoints.length ? tempPoints.map(p => p.label) : fallPoints.map(p => p.label || (p.x ? new Date(p.x).toLocaleString() : ''));
                const fallValues = (tempPoints.length ? tempPoints.map((p, i) => (fallPoints[i] && Number(fallPoints[i].y) > 0 ? 1 : null)) : fallPoints.map(p => (p.y > 0 ? 1 : null)));
                new Chart(document.getElementById('fallChart'), {
                    type: 'line',
                    data: {
                        labels: fallLabels,
                        datasets: [
                            { label: 'Falls Detected (1=yes)', data: fallValues, borderColor: 'red', pointRadius: 4, showLine: false }
                        ]
                    },
                    options: Object.assign({}, commonOptions, { scales: { x: commonOptions.scales.x, y: { beginAtZero: true, ticks: { stepSize: 1 } } } })
                });

                // Emotion chart
                const eLabels = emotionPoints.map(p => p.label);
                const eValues = emotionPoints.map(p => p.y);
                new Chart(document.getElementById('emotionChart'), {
                    type: 'line',
                    data: {
                        labels: eLabels,
                        datasets: [
                            { label: 'Emotion (0=Neutral,1=Happy,2=Sad,3=Surprised)', data: eValues, borderColor: 'purple', pointRadius: 2 }
                        ]
                    },
                    options: Object.assign({}, commonOptions, {
                        scales: { x: commonOptions.scales.x, y: { ticks: { callback: function(v) { const m = {0:'Neutral',1:'Happy',2:'Sad',3:'Surprised', '-1':'No Face'}; return m[v] !== undefined ? m[v] : v; }, stepSize: 1 } } },
                        plugins: { tooltip: { callbacks: { label: function(context) { const m = {0:'Neutral',1:'Happy',2:'Sad',3:'Surprised', '-1':'No Face'}; return `Emotion: ${m[context.parsed.y] ?? context.parsed.y}`; } } } }
                    })
                });

            } catch (error) {
                console.error('Error loading dashboard:', error);
            }
        }

        loadDashboard();
    </script>
</body>
</html>