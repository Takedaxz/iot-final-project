<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ElderSafe Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Use the UMD adapter bundle (v3) which matches Chart.js v4 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.min.js"></script>
    <script src="config.js"></script>
</head>
<body>
    <h1>ElderSafe Historical Dashboard</h1>
    <canvas id="tempChart" width="400" height="200"></canvas>
    <canvas id="humChart" width="400" height="200"></canvas>
    <canvas id="gForceChart" width="400" height="200"></canvas>
    <canvas id="fallChart" width="400" height="200"></canvas>
    <canvas id="emotionChart" width="400" height="200"></canvas>

    <script>
        // Function to calculate Simple Moving Average and return aligned points
        function calculateSMAPoints(points, windowSize) {
            // points: [{x: Date, y: number}]
            const values = points.map(p => (p.y == null ? 0 : p.y));
            const smaPoints = [];
            for (let i = 0; i < points.length; i++) {
                if (i < windowSize - 1) {
                    smaPoints.push({ x: points[i].x, y: null });
                } else {
                    const window = values.slice(i - windowSize + 1, i + 1);
                    const sum = window.reduce((a, b) => a + b, 0);
                    smaPoints.push({ x: points[i].x, y: sum / windowSize });
                }
            }
            return smaPoints;
        }

        // Map emotions to numbers for charting
        const emotionMap = {
            'Neutral': 0,
            'Happy': 1,
            'Sad': 2,
            'Surprised': 3,
            'No Face': -1
        };

        function toTimePoints(arr) {
            // Convert [{time, value}] -> [{x: Date, y: value}] and filter invalid dates
            const out = [];
            for (const d of (arr || [])) {
                const dt = new Date(d.time);
                if (isNaN(dt.getTime())) continue; // skip invalid timestamps
                const raw = d.value;
                const y = (typeof raw === 'number') ? raw : (isNaN(Number(raw)) ? null : Number(raw));
                out.push({ x: dt, y: y });
            }
            return out;
        }

        async function loadDashboard() {
            try {
                const response = await fetch(BASE_URL + '/dashboard_data');
                const data = await response.json();

                const tempPoints = toTimePoints(data.temp_data || []);
                const humPoints = toTimePoints(data.hum_data || []);
                const gForcePoints = toTimePoints(data.g_force_data || []);
                const fallPoints = (data.fall_data || []).map(d => ({ x: new Date(d.time), y: Number(d.value) }));
                const emotionPoints = (data.emotion_data || []).map(d => ({ x: new Date(d.time), y: (emotionMap[d.value] !== undefined ? emotionMap[d.value] : -1) }));

                const smaWindow = 5;
                const tempSMA = calculateSMAPoints(tempPoints, smaWindow);
                const humSMA = calculateSMAPoints(humPoints, smaWindow);
                const gForceSMA = calculateSMAPoints(gForcePoints, smaWindow);

                const commonOptions = {
                    parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                    plugins: { legend: { position: 'top' } },
                    scales: {
                        x: {
                            type: 'time',
                            time: { tooltipFormat: 'PP p', unit: 'hour', displayFormats: { hour: 'dd/MM HH:mm' } },
                            ticks: { maxRotation: 45, autoSkip: true, maxTicksLimit: 12 }
                        }
                    },
                    elements: { point: { radius: 0 }, line: { tension: 0.2 } },
                    interaction: { mode: 'nearest', intersect: false }
                };

                // Temperature
                new Chart(document.getElementById('tempChart'), {
                    type: 'line',
                    data: {
                        datasets: [
                            { label: 'Temperature (Â°C)', data: tempPoints, borderColor: 'red', backgroundColor: 'rgba(255,0,0,0.05)', fill: false, pointRadius: 2 },
                            { label: `Temperature SMA (${smaWindow})`, data: tempSMA, borderColor: 'orange', borderDash: [6, 4], pointRadius: 0 }
                        ]
                    },
                    options: commonOptions
                });

                // Humidity
                new Chart(document.getElementById('humChart'), {
                    type: 'line',
                    data: {
                        datasets: [
                            { label: 'Humidity (%)', data: humPoints, borderColor: 'blue', backgroundColor: 'rgba(0,0,255,0.05)', fill: false, pointRadius: 2 },
                            { label: `Humidity SMA (${smaWindow})`, data: humSMA, borderColor: 'cyan', borderDash: [6, 4], pointRadius: 0 }
                        ]
                    },
                    options: commonOptions
                });

                // G-Force
                new Chart(document.getElementById('gForceChart'), {
                    type: 'line',
                    data: {
                        datasets: [
                            { label: 'G-Force', data: gForcePoints, borderColor: 'green', backgroundColor: 'rgba(0,128,0,0.05)', fill: false, pointRadius: 2 },
                            { label: `G-Force SMA (${smaWindow})`, data: gForceSMA, borderColor: 'lime', borderDash: [6, 4], pointRadius: 0 }
                        ]
                    },
                    options: commonOptions
                });

                // Fall Detection (scatter) - show only points where value > 0
                new Chart(document.getElementById('fallChart'), {
                    type: 'scatter',
                    data: {
                        datasets: [
                            { label: 'Falls Detected', data: fallPoints.filter(p => p.y > 0), backgroundColor: 'red', pointRadius: 4 }
                        ]
                    },
                    options: Object.assign({}, commonOptions, { scales: { x: commonOptions.scales.x, y: { beginAtZero: true, ticks: { stepSize: 1 } } } })
                });

                // Emotion chart - map numeric back to labels in tooltip
                new Chart(document.getElementById('emotionChart'), {
                    type: 'line',
                    data: {
                        datasets: [
                            { label: 'Emotion (0=Neutral,1=Happy,2=Sad,3=Surprised)', data: emotionPoints, borderColor: 'purple', pointRadius: 2 }
                        ]
                    },
                    options: Object.assign({}, commonOptions, {
                        scales: { x: commonOptions.scales.x, y: { ticks: { callback: function(v) { const m = {0:'Neutral',1:'Happy',2:'Sad',3:'Surprised', '-1':'No Face'}; return m[v] !== undefined ? m[v] : v; }, stepSize: 1 } } },
                        plugins: { tooltip: { callbacks: { label: function(context) { const m = {0:'Neutral',1:'Happy',2:'Sad',3:'Surprised', '-1':'No Face'}; return `Emotion: ${m[context.parsed.y] ?? context.parsed.y}`; } } } }
                    })
                });

            } catch (error) {
                console.error('Error loading dashboard:', error);
            }
        }

        loadDashboard();
    </script>
</body>
</html>